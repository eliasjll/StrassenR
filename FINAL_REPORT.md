# Final Project Report: StrassenR - Fast Matrix Multiplication

## 1. Introduction
Matrix multiplication is a cornerstone of numerical computing, yet its standard O(n³) complexity presents a significant bottleneck for large-scale problems. This project, based on the original proposal ([link to your proposal]), confronts this challenge by developing `StrassenR`, an R package implementing Strassen's asymptotically faster O(n^2.807) algorithm.

The project's primary goal was twofold: first, to engineer a high-performance matrix multiplication tool by leveraging Rcpp and OpenMP; second, to meticulously document the development process as a tutorial for using Generative AI in a complex software engineering context. This report details the journey from simple R scripts to a parallelized C++ engine, with a special focus on the real-world debugging challenges encountered and the AI-assisted strategies used to solve them.

## 2. Background and Theory
The project implemented four versions of matrix multiplication, each representing a different level of optimization.

*   **Naive R (Baseline):** This is a direct translation of the mathematical formula into three nested `for` loops in R. Its O(n³) complexity is exacerbated by R's nature as an interpreted language, where loop-heavy code runs exceptionally slowly. It serves as the "worst-case" benchmark.

*   **Naive C++:** This uses the identical O(n³) triple-loop logic but is implemented in C++ via Rcpp. By compiling the code ahead of time, it eliminates R's interpreter overhead, resulting in a massive speedup. This version provides a fair baseline to isolate the *algorithmic* gains of Strassen's method from the gains of simply using a compiled language.

*   **Hybrid C++ (Strassen with Thresholding):** While Strassen's algorithm is asymptotically superior, its high overhead from numerous recursive calls and matrix additions makes it slower than the naive method for small matrices. The hybrid algorithm addresses this by stopping the recursion when the sub-matrix size drops below a `THRESHOLD` (e.g., 64x64). At that point, it switches to the faster Naive C++ implementation. This creates a practical, "best of both worlds" solution that is the most common way Strassen's algorithm is implemented in practice.

*   **Parallel C++ (Strassen with OpenMP):** This version enhances the Hybrid C++ algorithm for modern multi-core CPUs. The seven sub-problems (M1-M7) generated by each step of Strassen's recursion are computationally independent. Using OpenMP, these seven tasks can be distributed and executed simultaneously across multiple processor cores, leading to a significant reduction in wall-clock time for large matrices.

## 3. Methodology
The project's methodology was defined by a close collaboration with a Generative AI, primarily the Gemini CLI. A `gemini.md` file was maintained to provide the AI with persistent context about the project's goals, my C++ inexperience, and the current state of the code.

*   **GenAI-Driven Development:** The workflow followed a consistent pattern:
    1.  Define a weekly goal (e.g., "Translate the R code to Rcpp").
    2.  Prompt the AI for step-by-step instructions.
    3.  Use the AI-generated code as a starting point.
    4.  Compile the code, which would often fail due to my inexperience with C++.
    5.  Feed the exact C++ compiler error back to the AI with a prompt like: *"I used your code and got this error: `[paste error here]`. I think it's related to matrix subtraction. Can you fix it?"*
    6.  This iterative "prompt-code-error-prompt" cycle was the primary mechanism for both writing and debugging the C++ implementation.

*   **Algorithm Implementation:** The initial pure R functions were translated to C++ by the AI. Early C++ versions failed due to subtle issues like `const` correctness and the inability to create sub-matrix "views." The final, robust solution involved manually creating and copying data into padded matrices, a logic co-developed with the AI. Generalization to handle non-square matrices was achieved by padding the input matrices to the next power of two before entering the recursive engine.

*   **Optimization and Benchmarking:** A hybrid thresholding model was implemented to optimize performance. Parallelism was introduced using OpenMP, which required creating a `src/Makevars` file to pass the correct compiler flags—a task for which the AI provided the necessary configuration. The `microbenchmark` package was then used to find the optimal `THRESHOLD` value and generate performance comparison data.

## 4. Results and Discussion

*   **Benchmark Results Summary:**
    *[Insert your `performance_comparison.png` plot here. Your discussion should describe how the plot clearly shows four distinct performance tiers. `Naive_R` will be orders of magnitude slower than the others. `Naive_C++` will show a steep O(n³) curve. `Hybrid_C++` will start slower than `Naive_C++` but will eventually cross over and become significantly faster, demonstrating Strassen's superior asymptotic complexity. `Parallel_C++` will run parallel to the `Hybrid_C++` curve but will be vertically shifted down, showing a consistent speedup factor from multi-threading.]*

*   **Optimal Threshold:**
    *[State the optimal threshold you found (e.g., 64). Explain that this value represents the empirical point where the overhead of Strassen's recursive calls becomes more expensive than the raw computational cost of a naive triple-loop multiplication.]*

*   **Challenges and Solutions: The "Phantom" `NAMESPACE` Bug:**
    The project's most critical challenge was a "phantom" bug that appeared after the C++ code was compiling successfully. Any call to an Rcpp function failed with `Error: .Call(...) not available`. Initial AI suggestions pointed to common issues like stale build files, but these fixes did not work.

    The breakthrough came from a shift in prompting strategy—from asking for a fix to asking for a *diagnostic plan*.
    **Prompt:** *"My C++ code compiles, but I still get the .Call() not available error. The standard fixes aren't working. How can I diagnose if the problem is my Strassen code or the package build system itself?"*

    This led to the "Canary Test": we created a new, trivial C++ function (`add_one`). When it failed with the exact same error, it definitively proved the Strassen code was innocent and that the package's build system was fundamentally broken.

    With this knowledge, a new prompt—*"How does R find C++ functions? How do I check the build files?"*—led us to investigate the package's "glue" files. A check of `src/RcppExports.cpp` showed it was correct, but `readLines("NAMESPACE")` revealed the file was empty. It was missing the `useDynLib(StrassenR, .registration = TRUE)` directive, which is responsible for loading the compiled C++ library into R.

    The final solution was simple: running `devtools::document()`, which correctly regenerated the `NAMESPACE` file. This experience was a powerful lesson: the bug was not in the C++ code, but in the R package infrastructure, and it could only be solved by diagnosing the system as a whole.

## 5. Conclusion
This project successfully delivered the `StrassenR` package, achieving significant performance gains through algorithmic optimization and parallelization. More importantly, it served as a rigorous case study in modern, AI-assisted software development. The journey highlighted that while GenAI is a powerful code generator, its true value lies in its ability to act as a collaborative debugging partner. The most effective interactions were not those that simply asked for code, but those that asked for diagnostic strategies, enabling a deeper understanding of the complex interplay between C++, R, and the R package build system.

## 6. Future Work
The `StrassenR` package is a strong foundation that could be extended in several ways. The underlying C++ engine could be enhanced to support sparse matrices, which would be a significant advantage in many data science applications. Further performance could be gained by exploring lower-level SIMD (Single Instruction, Multiple Data) optimizations to parallelize the vector arithmetic within the naive base case.

## 7. Acknowledgements
I would like to thank the GenAI assistant, Gemini, for its indispensable role in this project. It functioned as an interactive C++ tutor, a tireless debugging partner, and an effective tool for generating documentation, making a project of this complexity achievable for a C++ novice.
