<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>StrassenR: A Tutorial • StrassenR</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="StrassenR: A Tutorial">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">


    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">StrassenR</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.0.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles

    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/development-log.html">Development Log</a>
    </li>
    <li>
      <a href="../articles/tutorial.html">StrassenR: A Tutorial</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->



      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>StrassenR: A Tutorial</h1>
            
      

      <div class="hidden name"><code>tutorial.Rmd</code></div>

    </div>

    
    
<div class="section level2">
<h2 id="the-problem-with-matrix-multiplication-in-r">The Problem with Matrix Multiplication in R<a class="anchor" aria-label="anchor" href="#the-problem-with-matrix-multiplication-in-r"></a>
</h2>
<p>Matrix multiplication is a fundamental operation in almost every
field of scientific computing, but it’s computationally expensive and
can take a long amount of time to compute for larger matrices. The
standard matrix multiplication algorithm that uses 3 nested loops has a
time complexity of O(n³), which means that if you double the size of
your matrices, the computation time increases by a factor of eight. As
you can see from this plot of R’s built in matrix multiplication
algorithm performance, this cubic growth quickly becomes a bottleneck.
For large matrices, run times can become too long to be practical. Our
goal is to break through this O(n³) wall.</p>
<div class="figure">
<img src="tutorial_files/figure-html/r-performance-plot-1.png" class="r-plt" alt="Performance of R's Native Matrix Multiplication" width="700"><p class="caption">
Performance of R’s Native Matrix Multiplication
</p>
</div>
</div>
<div class="section level2">
<h2 id="strassens-algorithm">Strassen’s Algorithm<a class="anchor" aria-label="anchor" href="#strassens-algorithm"></a>
</h2>
<p>The solution for this is Strassen’s algorithm. It’s a ‘divide and
conquer’ method that rearranges the math to reduce the number of
required multiplications from 8 in the standard matrix multiplication
method down to 7. This single reduction in multiplication drops the
complexity from O(n³) to approximately O(n^2.807) which is a huge
theoretical improvement. However, it comes at the cost of more additions
and subtractions, which creates overhead. This means that for small
matrices Strassen’s can actually be slower than the naive method, which
is a trade-off that becomes important later on. Finally Starssen’s
algorithm is typically used for 2nx2n sized matrices but by padding
these matrices with 0s we can get them to 2nx2n which then allows the
algorithm to work.</p>
<p><img src="images/strassen-formulas.png"></p>
</div>
<div class="section level2">
<h2 id="genai-workflow-1-r-to-c-translation">GenAI Workflow 1: R-to-C++ Translation<a class="anchor" aria-label="anchor" href="#genai-workflow-1-r-to-c-translation"></a>
</h2>
<p>To make this run fast, I needed to implement it in C++ using rcpp,
but since I had never coded in C++ before I decided to use Gemini CLI to
implement any code I would need in that language. I started by writing
the algorithm in pure R to get the logic right, and then asked the AI to
translate it into C++. This led to the first challenge I faced with the
AI. The AI’s direct translation produced C++ code that looked like R
code, for example, using the plus operator for matrix addition which
doesn’t exist in C++. This definitely helped me see early on that the
gen AI can make incorrect assumptions, and its output needs to be
heavily looked over and debugged.</p>
</div>
<div class="section level2">
<h2 id="genai-workflow-2-iterative-c-debugging">GenAI Workflow 2: Iterative C++ Debugging<a class="anchor" aria-label="anchor" href="#genai-workflow-2-iterative-c-debugging"></a>
</h2>
<p>This led to the core iterative workflow I used for working with
generative AI for the entire project. As shown in the flowchart, the
process was a simple loop:</p>
<ol style="list-style-type: decimal">
<li>First, I’d prompt the AI with a goal for what I wanted for a new
section of code</li>
<li>Then, I’d generate and test the code it gave me.</li>
<li>I’d verify if it worked and produced the right result.</li>
<li>If not, I would go back to the AI with the new error message.</li>
</ol>
<p>This ‘call and response’ cycle was incredibly effective for me.
Because I initially instructed gemini cli in its md file to act as a
teacher and explain all C++ code it produced for me, this turned
compiler errors into learning moments for me, allowing me to build and
understand complex C++ code with no prior experience.</p>
<p><img src="images/debugging-flowchart.png"></p>
<p><img src="images/gemini-error-loop.png"></p>
</div>
<div class="section level2">
<h2 id="the-hybrid-algorithm">The Hybrid Algorithm<a class="anchor" aria-label="anchor" href="#the-hybrid-algorithm"></a>
</h2>
<p>Strassen’s overhead makes it inefficient for small matrices. To solve
this, I implemented a ‘hybrid’ algorithm. The logic this algorithm uses
is if the matrix size is above a certain THRESHOLD, we use Strassen’s
method. But if it’s smaller than the threshold, we switch to a fast,
standard C++ loop to avoid time loss from Strassen’s overhead. To find
the best THRESHOLD, I benchmarked the algorithm at various matrix sizes
from 2^4 to 2^8. From the benchmark I found that the optimal crossover
point was 64.</p>
<pre><code><span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Attaching package: 'dplyr'</span></span>
<span><span class="co">#&gt; The following objects are masked from 'package:stats':</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;     filter, lag</span></span>
<span><span class="co">#&gt; The following objects are masked from 'package:base':</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;     intersect, setdiff, setequal, union</span></span></code></pre>
<div class="figure">
<img src="tutorial_files/figure-html/threshold-plot-1.png" class="r-plt" alt="Optimal Crossover Threshold for Hybrid Algorithm" width="700"><p class="caption">
Optimal Crossover Threshold for Hybrid Algorithm
</p>
</div>
</div>
<div class="section level2">
<h2 id="parallelism-with-openmp">Parallelism with OpenMP<a class="anchor" aria-label="anchor" href="#parallelism-with-openmp"></a>
</h2>
<p>The final optimization was to introduce parallelism, which is the
simultaneous execution of multiple calculations or processes. The 7
recursive calls in Strassen’s algorithm are completely independent of
each other, making them a perfect target for parallelization. Using a
library called OpenMP, I was able to produce C++ code that tells the
compiler to execute these 7 tasks simultaneously across all available
CPU cores as opposed to the single core which is what R will normally
do. As the diagram shows, this turns a sequential process into a
parallel one, significantly reducing the total execution time for large
matrices.</p>
<p><img src="images/openmp-diagram.png"></p>
</div>
<div class="section level2">
<h2 id="final-functionsperformances">Final Functions/Performances<a class="anchor" aria-label="anchor" href="#final-functionsperformances"></a>
</h2>
<p>This is the final results. This plot shows the performance of all the
versions of the matrix algorithms I created, as well as r’s built in
matrix operator. From the graph we can see there are two tiers of speed
specifically for smaller matrix sizes, with the default Strassens and
naive C++ algorithms performing the slowest, and the hybrid, parallel,
and default r algorithms performing the fastest. The reason that R’s
default matrix multiplication is so fast is because it uses extremely
optimized and fast BLAS/LAPACK libraries. Despite it being so highly
optimized, I was able to get both the hybrid and parallel
implementations of strassens algorithm both faster than R as the matrix
size increased, with Parallel beating r at n=130 and hybrid_strassen
beating r at n=1198.</p>
<div class="figure">
<img src="tutorial_files/figure-html/projection-plot-1.png" class="r-plt" alt="Projected vs. Actual Performance of Matrix Multiplication Algorithms" width="700"><p class="caption">
Projected vs. Actual Performance of Matrix Multiplication Algorithms
</p>
</div>
</div>
<div class="section level2">
<h2 id="takeaways-from-using-gen-ai">Takeaways from using Gen AI<a class="anchor" aria-label="anchor" href="#takeaways-from-using-gen-ai"></a>
</h2>
<p>Through completing this project, I was able to get some key takeaways
about working with gemini cli. I found that Gemini did a great job of
helping to understand and optimize code, as well as being a great
teacher for helping me learn how to code in C++ in the first place.
However, I did find that for larger prompts, Gemini would often make
assumptions that would lead to errors. I also had a repeated problem
where it sometimes got stuck in a loop, like in this screenshot where it
repeatedly kept trying the incorrect solution. This highlighted for me
the need for human oversight and showed that sometimes, the easiest
solution is to just restart that part of the code from scratch, which is
what I did in this example.</p>
<p><img src="images/gemini-error-loop.png"></p>
</div>
<div class="section level2">
<h2 id="conclusion-future-improvements">Conclusion &amp; Future Improvements<a class="anchor" aria-label="anchor" href="#conclusion-future-improvements"></a>
</h2>
<p>In conclusion, I was able to successfully build and optimize a
high-performance R package that outperforms R’s built-in matrix
multiplication operator through the use of Gemini CLI as a debugging
partner. The reason why I used Strassen’s Algorithm and not a different
one with a lower time complexity is because Strassens is the matrix
multiplication method with the lowest time complexity that is not a
galactic algorithm. This means that for all matrix multiplication
methods with a lower time complexity than strassens, we would only start
to see performance gains for problems that are so large they never
occur. For next steps, I would replace the naive C++ base case used in
the thresholding algorithm with a call to a dedicated BLAS library to
hopefully greatly decrease the execution time. I would also update the
code to implement the Strassen-Winograd variant of Strassens algorithm,
a version that requires less addition and subtraction and should
theoretically reduce execution time.</p>
<p><img src="images/omega-bounds.png"></p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

      </div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Elias Lindquist.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.2.0.</p>
</div>

      </footer>
</div>






  </body>
</html>
